# php

## php 基础

### include、require、 include_once、require_once

include：当引入一个空文件时，页面只会报一行错误。

require：当引入一个空文件时，页面会报致命错误。

include_once与include;require_once与require它们的作用差不多，唯一区别是include_once,require_once它们不会获取重复的代码。

### 值传递和引用传递的区别

值传递：就是将一个变量的值，复制给另一个变量

引用传递：是将变量的值，在内存中的地址，传递给另一个变量，如果一个发生改变时，另一个变量的值，也会发生变化。 

### Print、echo、print_r有什么区别？

1.  echo和print都可以做输出，不同的是，echo不是函数，没有返回值，而print是一个函数有返回值，所以相对而言如果只是输出echo会更快，而print_r通常用于打印变量的相关信息，通常在调试中使用。
2.  print 是打印字符串
3. print_r 则是打印复合类型 如数组 对象

### SESSION与COOKIE的区别？

1. 存储位置：session存储于服务器，cookie存储于浏览器
2. 安全性：session安全性比cookie高
3. session为‘会话服务’，在使用时需要开启服务，cookie不需要开启，可以直接用

### PHP操作文件的常用函数？

1. 打开文件 fopen()
2. 读取文件 fgets() ; 注：file_get_contents()也是读取文件
3. 写入文件fwrite() ; 注：file_put_contents()同样可以写入文件
4. 关闭文件句柄 fclose()
5. 移动 / 重命名文件 rename()
6. 复制文件 copy()
7. 创建文件 vim 或 touch
8. 删除文件 unlink()
9. 获取文件上次访问的时间 fileatime()
10. 获取文件上次修改的时间 filemtime()
11. 获取文件大小 filesize()
12. 获取文件类型 filetype()
13. 获取文件详细信息 state()
14. 判断是否是目录 is_dir()

### PHP操作目录（文件夹）的常用函数？

1. 打开目录 opendir()
2. 读取目录 readdir()
3. 删除目录 rmdir()
4. 关闭目录句柄 closedir()
5. 创建目录 mkdir()
6. 返回路径中的目录部分 dirname()
7. 取得当前工作目录 getcwd()
8. 列出指定路径中的文件和目录 scandir()

### PHP处理数组的常用函数？

1. array() 创建数组
2. in_array() 判断元素是否在数组中
3. count() 返回数组中元素的数目
4. array_merge() 将多个数组合并成一个数组
5. array_diff() 比较两个或两个以上数组的差异
6. array_intersect() 获取两个或两个数组以上的交集
7. array_keys() 获取数组的key列表
8. array_values() 获取数组的值列表
9. array_unique() 删除数组中的重复值
10. array_push()将一个或多个元素插入数组的末尾（入栈）
11. array_pop() 弹出并返回 array 数组的最后一个单元（出栈）
12. array_walk() 使用用户自定义函数对数组中的每个元素做回调处理
13. array_combine(前面数组作为其键，后面数组做为其值)
14. array_merage(合并两个数组，后面覆盖前面，但数字索引会重新索引，不会覆盖)

### PHP处理字符串的常用函数？

1. trim() 移除字符串两侧的空白字符和其他字符
2. strlen() 获取字符串的长度
3. mb_strlen() 获取字符串长度（可指定字符编码，对中文字符串计算长度）
4. substr()返回字符串的一部分；
5. str_replace() 子字符串替换
6. str_repeat () 重复一个字符串
7. is_string() 检测变量是否是字符串；
8. str_shuffle () 随机打乱一个字符串
9. sprintf() 返回根据格式化字符串生成的字符串（通常用于获取分表后的数据表名）
10. strstr() 查找字符串的首次出现
11. addslashes 使用反斜线引用字符串

### PHP处理时间的常用函数？（重点看函数的‘参数’和‘返回值’）

1. date() 格式化一个本地时间／日期。
2. getdate() 取得日期／时间信息。
3. date_default_timezone_set() 设定默认时区。
4. date_default_timezone_get() 返回默认时区。
5. mktime() 返回一个日期的 Unix时间戳。
6. strtotime() 将任何字符串的日期时间描述解析为 Unix 时间戳
7. strftime() 根据区域设置格式化本地时间／日期

#### **session共享问题解决方案**

a. 客户端Cookie保存，以cookie加密的方式保存在客户端，每次session信息被写在客服端，然后经浏览器再次提交到服务器。

b. 服务器间Session同步，使用主-从服务器的架构，当用户在主服务器上登录后，通过脚本或者守护进程的方式，将session信息传递到各个从服务器中

c. 使用集群统一管理Session，当应用系统需要session信息的时候直接到session群集服务器上读取，目前大多都是使用redis来对Session进行存储。

d. 把Session持久化到数据库，目前采用这种方案时所使用的数据库一般为mysql。

#### **介绍一下常见的SSO(单点登陆)的原理。**

SSO是一种统一认证和授权机制，通过一个应用中的安全验证后，再访问其他应用中的受保护资源时，不再需要重新登录验证。

解决了用户只需要登录一次就可以访问所有相互信任的应用系统，而不用重复登录。

统一的认证系统是SSO的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；

认证成功后，认证系统应该生成统一的认证标志（ticket），返还给用户。另外，认证系统还应该对ticket进行效验，判断其有效性。

#### **禁掉cookie的session使用方案**

a. 通过 url 传值，把session id附加到url上（缺点：整个站点中不能有纯静态页面，因为纯静态页面session id 将无法继续传到下一页面）

b. 通过隐藏表单，把session id 放到表单的隐藏文本框中同表单一块提交过去（缺点：不适用<a>标签这种直接跳转的非表单的情况）

c. 直接配置php.ini文件,将php.ini文件里的session.use_trans_sid= 0设为1（好像在win上不支持）

d. 用文件、数据库等形式保存Session ID，在跨页过程中手动调用

#### **isset() 、empty()与is_null的区别**

isset()：仅当null和未定义，返回false

empty()：''、0、'0'、NULL、FALSE、array(),未定义，均返回true

is_null()：仅判断是否为null，未定义 报警告

#### **接口与抽象类的区别是什么？**

**抽象类：**

抽象类是不能被实例化的类，只能作为其他类的父类来使用，抽象类是通过关键字abstract来声明

抽象类与普通类类似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少包含一个抽象方法

抽象方法没有方法体，该方法天生就是要被子类重写的

抽象方法的格式为：abstract function abstractMethod()

子类继承抽象类使用extends

**接口：**

接口是通过interface关键字来声明，接口中的成员常量和方法都是public的，方法可以不写关键字public

接口中的方法也是没有方法体的，接口中的方法也是天生要被子类实现的

接口能实现多继承

子类实现接口使用implements

#### **echo，print()，print_r()，printf()，sprintf()，var_dump()有什么区别**

echo：是语句不是函数，没有返回值，可输出多个变量值，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)

print：是语句不是函数，有返回值 1 ，只能输出一个变量，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。

print_r：是函数，可以打印复合类型，例如：stirng、int、float、array、object等，输出array时会用结构表示，

而且可以通过print_r($str,true)来使print_r不输出而返回print_r处理后的值

printf：是函数，把文字格式化以后输出（参看C语言）

sprintf：是函数，跟printf相似，但不打印，而是返回格式化后的文字，其他的与printf一样。

var_dump：函数，输出变量的内容、类型或字符串的内容、类型、长度。常用来调试。

#### **写个函数来解决多线程同时读写一个文件的问题**

首先用fopen打开某个文件，然后flock加锁，再用fwrite写内容，接着flock释放锁，最后fclose关闭文档

#### **php获取文件内容的方法，对应的函数**

a. file_get_contents得到文件的内容（可以以get和post的方式获取），整个文件读入一个字符串中

b. 用fopen打开url, 以get方式获取内容（借助fgets()函数）

c. 用fsockopen函数打开url（可以以get和post的方式获取），以get方式获取完整的数据，包括header和body

d. 使用curl库获取内容，使用curl库之前，需要查看php.ini，查看是否已经打开了curl扩展

#### **Apache与Nginx的优缺点比较**

**a. nginx相对于apache的优点：**

轻量级，比apache 占用更少的内存及资源。高度模块化的设计，编写模块相对简单

抗并发，nginx 处理请求是异步非阻塞，多个连接（万级别）可以对应一个进程，而apache 则是阻塞型的，是同步多进程模型，一个连接对应一个进程，在高并发下nginx 能保持低资源低消耗高性能

nginx处理静态文件好，Nginx 静态处理性能比 Apache 高 3倍以上

**b. apache 相对于nginx 的优点：**

apache 的rewrite 比nginx 的rewrite 强大 ，模块非常多，基本想到的都可以找到 ，比较稳定，少bug ，nginx 的bug 相对较多

#### **MVC的优缺点**

**优点：**

分散关注、松散耦合、逻辑复用、标准定义

a. 开发人员可以只关注整个结构中的其中某一层，方便多开发人员间的分工

b. 可以很容易的用新的实现来替换原有层次的实现

c. 降低层与层之间的依赖

d. 利于各层逻辑的复用，有利于标准化

e. 对单元测试的支持更加出色

**缺点：**

a. 清晰的构架以代码的复杂性为代价， 对小项目优可能反而降低开发效率

b. 降低了系统的性能，例如业务造访数据库现在必须通过中间层来完成

c. 控制层和表现层有时会过于紧密，导致没有真正分离和重用

d. 有时会导致级联的修改，如果在表示层中增加一个功能，为保证符合分层式结构，可能需要在相应的控制层和模型层中都增加相应的代码

## php 中级

### php代码解释过程

- lexical词法分析，输入为源代码，输出为token

- 语法分析 工具为文法（LALR），输出为表达式，7.0为AST，涉及:

  ```
  - 注释
  - 分号 & 分隔符
  - 变量
  - 常量
  - 操作数
  ```

- 类型检查、关键字处理、导入，输出为中间代码。工具为选定的的编译器优化工具

  ```
  - 中间代码生成（Opcodes）
  - 机器码生成（编译语言）
  ```

### php进程间如何通信

- 信号量（消息同步|互斥）（pv操作） sem_*
- 信号(信号触发事件)（pcntl_signal, pcntl_wait*）
- 消息队列 msg_*
- 管道(pipe)
- socket |unix _*.sock
- 共享内存(shm_*,shmop_*)

### php垃圾回收机制（gc）

- zend.enable_gc `php.ini`
- gc_enable() `funciton`
- 引入计数（zval指向zend_value个数为0时）+写时拷贝（copy on write）
- 循环引用问题（array、object引用自身成员），垃圾回收器将其收集至于一个buffer（_zend_gc_global->gc_root_buffer）后启动垃圾鉴定程序

### **PHP处理上传文件信息数组中的文件类型$_FILES[‘type’]由客户端浏览器提供，有可能是黑客伪造的信息，请写一个函数来确保用户上传的图像文件类型真实可靠**

用getimagesize来判断上传图片的类型比$_FILES函数的type更可靠

同一个文件，使用不同的浏览器php返回的type类型是不一样的，由浏览器提供type类型的话，

就有可能被黑客利用向服务器提交一个伪装撑图片后缀的可执行文件。

可以通过getimagesize()函数来判断上传的文件类型，如果是头像文件 会返回这样的一个数组

### 如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞？

答：基本原则：不对外界展示服务器或程序设计细节（屏蔽错误），不相信任何用户提交的数据（过滤用户提交）

1. 屏蔽错误，将display_errors 设置为off
2.  过滤用户提交参数，这里需要注意的是不能仅仅通过浏览器端的验证，还需要经过服务器端的过滤
3. 可以考虑设置统一入口，只允许用户通过指定的入口访问，不能访问未经许可的文件等内容
4. 可以考虑对安全性要求高的文件进行来源验证

### 面向对象有什么特征

面向对象的主要特征有抽象、继承、封装和多态。

1. 抽象。抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2. 继承。继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且子类可以修改或增加新的方法使之更适合特殊的需要。
3. 封装。封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护。类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的信息进行隐藏。
4. 多态。多态是指允许不同类的对象对同一消息做出响应。多态包括参数化多态和包含多态。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好地解决了应用程序函数同名问题。

### 什么是构造函数和析构函数

构造函数 `__construct` 的作用就是当类被实例化的时候会被自动调用，因此构造函数主要用于做一些初始化的工作。

子类的构造函数不会隐式地去调用父类的构造函数，需要开发者通过parent::__construct()来显式地去调用父类的构造函数。当子类没有定义构造函数的时候，它会继承父类的构造函数，但前提是父类的构造函数不能被定义为private。

 析构函数`__destruct`在对象被销毁时自动执行

### 面向对象的作用域范围有哪几种？

在PHP5中，类的属性或者方法主要有public、protected和private三种类作用域，它们的区别如下：

1. public（公有类型）表示全局，类内部、外部和子类都可以访问。
   默认的访问权限为public，也就是说，如果一个方法没有被public、protected或private修饰，那么它默认的作用域为public。
2. protected（受保护类型）表示受保护的，只有本类或子类可以访问。
   在子类中，可以通过self::var或self::method访问，也可以通过parent::method来调用父类中的方法。
   在类的实例化对象中，不能通过$obj->var来访问protected类型的方法或属性。
3. private（私有类型）表示私有的，只有本类内部可以使用。
   该类型的属性或方法只能在该类中使用，在该类的实例、子类、子类的实例中都不能调用私有类型的属性和方法。

### **PHP种魔术方法有哪些**

#### `__get`、`__set`、`__isset`、`__unset`

1. 在访问类属性的时候，若属性可以访问，则直接返回；若不可以被访问，则调用 `__get()`
2. 在设置一个对象的属性时，若属性可以访问，则直接赋值；若不可以被访问，则调用`__set()` 
3. 当对不可访问的属性调用 isset() 或 empty() 时，`__isset()` 会被调用。
4. 当对不可访问属性调用 unset() 时，`__unset() ` 会被调用

#### __ call()和__callStatic()

1. `__call( $method, $arg_array )`当调用一个不可访问的方法时会调用这个方法。
2. callStatic的工作方式与 `__call()` 类似，当调用的静态方法不存在或权限不足时，会自动调用`__callStatic()`。

### this、self和parent的区别是什么？

1. self是指向类本身，也就是self是不指向任何已经实例化的对象，一般self用来访问类中的静态变量。
2. parent是指向父类的指针，一般使用parent来调用父类的构造函数。
3. this指的是指向当前对象的指针

### **长连接、短连接的区别和使用**

长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。

短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。

长连接与短连接的使用时机：

长连接：

短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连 接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。

短连接：

web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像 web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。

### HTTP 响应状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：

1xx：指示信息 -- 表示请求已接收，继续处理

2xx：成功 -- 表示请求已被成功接收、理解、接受

3xx：重定向 -- 要完成请求必须进行更进一步的操作

4xx：客户端错误 -- 请求有语法错误或请求无法实现

5xx：服务器端错误 -- 服务器未能实现合法的请求

常见状态代码、状态描述、说明：

200 OK // 客户端请求成功

400 Bad Request // 客户端请求有语法错误，不能被服务器所理解

401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden // 服务器收到请求，但是拒绝提供服务

404 Not Found // 请求资源不存在，eg：输入了错误的 URL

500 Internal Server Error // 服务器发生不可预期的错误

503 Server Unavailable // 服务器超时 // 可能恢复正常

304 Not Modifed // 自从上次请求后，请求的网页未修改过。

// 服务器返回此响应时，不会返回网页内容。

### **socket 连接步骤**

Socket（套接字）概念

套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

Socket 连接过程

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket

套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。

客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端

套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

### **常见的 web 攻击方式**

常见攻击

XSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入的恶意 html 代码会被执行，从而达到恶意用户的特殊 目的。

XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。但是随着前端技术的不断进步富客户端的应用越来越多，这方面的问题越来 越受关注。

举个简单例子 ：

假如你现在是 sns 站点上一个用户，发布信息的功能存在漏洞可以执行 js 你在 此刻输入一个 恶意脚本，那么当前所有看到你新信息的人的浏览器都会执行这个脚本弹出提示框 （很爽吧 弹出广告 ：）），如果你做一些更为激进行为呢 后果难以想象。

CSRF (Cross Site Request Forgery)，跨站点伪造请求。顾名思义就是 通过伪造连接请求在用户不知情的情况下，让用户以自己的身份来完成攻击者需要达到的一些目的。csrf 的攻击不同于 xss csrf 需要被攻击者的主动行为触发。这样听来似乎是有 “被钓鱼” 的嫌疑。

多窗口浏览器这这方面似乎是有助纣为虐的嫌疑，因为打开的新窗口是具有当前所有 会话的，如果是单浏览器窗口类似 ie6 就不会存在这样的问题，因为每个窗口都是一个独立的进程。

举个简单例子 ： 你正在玩白社会， 看到有人发了一个连接，你点击过去，然后这个连接里面伪造了一个送礼物的表单，这仅仅是一个简单的例子，问题可见一般。

cookie 劫持。通过获取页面的权限，在页面中写一个简单的到恶意站点的请 求，并携带用户的 cookie 获取 cookie 后通过 cookie 就可以直以被盗用户的身份登录站点。这就是 cookie 劫持。

举个简单例子： 某人写了一篇很有意思的日志，然后分享给大家，很多人都点击查看并且分享了该日志，一切似乎都很正常，然而写日志的人却另有用心，在日志中偷偷隐藏了一个 对站外的请求，那么所有看过这片日志的人都会在不知情的情况下把自己的 cookie 发送给了 某人，那么他可以通过任意一个人的 cookie 来登录这个人的账户。

SQL 注入攻击

在 SQL 注入攻击 中，用户通过操纵表单或 GET 查询字符串，将信息添加到数据库查询中。

DNS 攻击

拒绝服务攻击

拒绝服务攻击即攻击者想办法让目标机器停止提供服务，是黑客常用的攻击手段之。

攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用 IP 欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接

### **PHP 做好防盗链的基本思想 防盗链**

什么是盗链？

盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面 (如广告)，直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。

网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。 如何做防盗链？

不定期更名文件或者目录

限制引用页

原理是，服务器获取用户提交信息的网站地址，然后和真正的服务端的地址相比较， 如果一致则表明是站内提交，或者为自己信任的站点提交，否则视为盗链。实现时可以使用 HTTP_REFERER1 和 htaccess 文件 (需要启用 mod_Rewrite)，结合正则表达式去匹配用户的每一个访问请求。

文件伪装

文件伪装是目前用得最多的一种反盗链技术，一般会结合服务器端动态脚本 (PHP/JSP/ASP)。实际上用户请求的文件地址，只是一个经过伪装的脚本文件，这个脚本文件会对用户的请求作认证，一般会检查 Session，Cookie 或 HTTP_REFERER 作为判断是否为盗链的依据。而真实的文件实际隐藏在用户不能够访问的地方，只有用户通过验证以后才会返回给用户

加密认证

这种反盗链方式，先从客户端获取用户信息，然后根据这个信息和用户请求的文件名 字一起加密成字符串 (Session ID) 作为身份验证。只有当认证成功以后，服务端才会把用户需要的文件传送给客户。一般我们会把加密的 Session ID 作为 URL 参数的一部分传递给服务器，由于这个 Session ID 和用户的信息挂钩，所以别人就算是盗取了链接，该 Session ID 也无法通过身份认证，从而达到反盗链的目的。这种方式对于分布式盗链非常有效。

随机附加码

每次，在页面里生成一个附加码，并存在数据库里，和对应的图片相关，访问图片时和此附加码对比，相同则输出图片，否则输出 404 图片

加入水印

### resultful

- get：获取资源
- post：新建资源
- put:更新完整资源
- delete：删除资源
- patch：更新部分资源



## redis 面试

#### Redis 能干嘛

1. 内存存储、持久化（rdb、aof）
2. 效率高，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器
6. 消息队列
7. 排行榜

redis（这块说的太乱了，回头我好好整理下~）

### 应用场景

- string：cache，incr（此时redisObject encoding为int）
- hash ：key为key，value为Hashmap（少时用redisObject encoding ziplist OR 增大时为ht）
- set：去重（中奖只一次sismember），交，并，差（如微博社交关系），内部实现为value为null的hashmap
- zset: 或者叫sorted set。既去重又能保证按照score排序，比如按照帖子的关注个数排序，value为帖子id，个数为score。面试中常问其实现机制（跳跃列表（skiplist）：用多个指针分层串起来+hashmap（本身hashmap无法进行二分查找，所以必须加持skiplist机制）），另外还有一个应用可以是消息优先级。
- list：（阻塞rpop）消息队列、列表旋转（常用于监控，rpoplpush）
- HyperLogLog：大量统计（非精确）
- bitmaps

### zset如何根据两个属性排序？比如根据id和age

- 可以用位操作，把两个属性合成一个double
- 用zunionstore合并存储为新的key，再zrange

### redis是如何保证原子性操作的？

- 因为他是tm单线程的！（ps:mysql是多线程）
- 在并发脚本中的get set等不是原子的~
- 在并发中的原子命令incr setnx等是原子的
- 事务是保证批量操作的原子性

### 主从复制过程：

1. 从服务器向主服务器发送sync
2. 主服务器收到sync命令执行BGSAVE,且在这期间新执行的命令保存到一个缓冲区
3. 主执行（BGSAVE）完毕后,将.rdb文件发送给从服务器，从服务器将文件载入内存
4. BGSAVE期间到缓冲区的命令会以redis命令协议的方式，将内容发送给从服务器。

### 备份与持久化

- rdb（fork 进程dump到file，但是注意触发节点的覆盖问题，导致数据不完整）
  - 手动： save （阻塞） & bgsave（fork 子进程），但是这两个不会同时进行（避免竟态条件）
  - 自动触发： `conf:save 900 1 save 300 10 save 60 10000 dbfilename dump.rdb`
  - rdb优点：对服务进程影响小，记录原数据文件方式便于管理还原
  - rdb缺点：可能数据不完整
  - rdb为非纯文本文件，可以用od -c dump.rdb分析
- aof（类似binlog）
  - 三种写入同步方式
    - appendfsync no
    - appendfsync everysec（每个事件循环写入缓冲区，但是每隔一秒同步到磁盘文件）
    - appendfsync always （每执行一个命令，每个事件循环都会执行写入aof 缓冲区并同步到磁盘文件，效率最慢，但是最安全）
  - aof优点：数据最完整，可以通过数据重写rewrite来减少体积，存储内容为redis的纯文本协议
  - aof缺点:文件相对rdb更大，导入速度比rdb慢
  - 一般有了aof就不rdb，因为aof更新频率更

### 过期策略：

- 定时过期：时间到了立即删除，cpu不友好，内存友好。
- 惰性过期：访问时判断是否过期：cpu友好，内存不友好
- 定期过期：expires dict中scan，清除已过期的key。cpu和内存最优解

### redis队列特殊关注（可能坑）之处

1. 队列可能丢东西
   - 比如redis挂了，producer没有停止，但是队列数据无法写入（除非同步落地到mysql）
2. 队列的consumer 需要手动处理commit协议
   - 如果consumer处理完，表示真正完成
   - 如果没有处理完？放回队列？直接丢弃？
3. 事件重放机制不支持
   - 比如consumer消费错了，那能不能将队列回放呢再次处理呢？
4. 队列最大长度及过期时间
   - 如果producer远大于consumer，撑爆了怎么办
   - 如果comsumer 一直没有处理，producer的数据如何处理
5. exactly once
6. 单机锁`sennx`或者基于`set`众多参数没问题，集群下可利用tag机制
7. 如何保证业务执行时间超过锁的过期时间，而引起误删除操作。答案是可以加一个唯一标识

### Redis key的过期时间和永久有效分别怎么设置？

`EXPIRE`和`PERSIST`命令。

### 怎么理解Redis事务？

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

### 使用过Redis分布式锁吗，它是怎么实现的？

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？ set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的

### 什么是缓存穿透？如何避免？

**缓存穿透**

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**如何避免？**

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
2. 对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。

### 什么是缓存雪崩？何如避免？

**缓存雪崩** 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。

**如何避免？**

1. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
2. 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

### string

```sh
127.0.0.1:6379> FLUSHALL		# FLUSHALL [ASYNC] 清空当前数据库
OK
127.0.0.1:6379> set name xhl	# SET key value 设置值
OK
127.0.0.1:6379> keys *		#	KEYS pattern 获取符合规则的key
1) "name"
127.0.0.1:6379> get name	# GET key value 获取key
"xhl"
127.0.0.1:6379> EXISTS name		# EXISTS key 判断 key 是否存在 1 存在 0 不存在
(integer) 1
127.0.0.1:6379> EXISTS name1 
(integer) 0
127.0.0.1:6379> move name 1		# MOVE key index 移动到目标数据库
(integer) 1
127.0.0.1:6379> keys *
(empty list or set)
127.0.0.1:6379> select 1		# SELECT index 切换数据库
OK
127.0.0.1:6379[1]> keys *
1) "name"
127.0.0.1:6379[1]> move name 0
(integer) 1
127.0.0.1:6379[1]> select 0
OK
127.0.0.1:6379> keys *
1) "name"
127.0.0.1:6379> EXPIRE name 10	# EXPIRE key time 设置 key 过期时间，单位秒
(integer) 1
127.0.0.1:6379> ttl name	#	TTL key 查看剩余时间
(integer) 7
127.0.0.1:6379> ttl name
(integer) 2
127.0.0.1:6379> ttl name
(integer) 1
127.0.0.1:6379> ttl name
(integer) 0
127.0.0.1:6379> ttl name
(integer) -2
127.0.0.1:6379> get name
(nil)
127.0.0.1:6379> keys *
(empty list or set)
127.0.0.1:6379> set key 1
OK
127.0.0.1:6379> type key	#	TYPE key 查看 value 类型
string
127.0.0.1:6379> set key 1	# SET key 设置值
OK
127.0.0.1:6379> APPEND key 1 # APPEND key value 追加字符串内容，如果 key 不存在，则相当于 set key > append key
(integer) 2
127.0.0.1:6379> APPEND key 1	
(integer) 3
127.0.0.1:6379> get key
"111"
127.0.0.1:6379> STRLEN key	#	STRLEN key 字符串长度
(integer) 3
127.0.0.1:6379> set views 0
OK
#########
127.0.0.1:6379> incr views	# INCR key 自增 1
(integer) 1
127.0.0.1:6379> incr views
(integer) 2
127.0.0.1:6379> decr views 	# DECR key 自减 1
(integer) 1
127.0.0.1:6379> INCRBY views 10	# INCRBY key steps 自增 N 
(integer) 11
127.0.0.1:6379> DECRBY views 10	# DECRBY key steps 自减 N 
(integer) 1
#########
127.0.0.1:6379> set str '123456789'
OK
127.0.0.1:6379> GETRANGE str 0 3 	# GETRANGE key start end 截取字符串 GETRANGE key start end
"1234"
127.0.0.1:6379> GETRANGE str 0 -1 # 
"123456789"
127.0.0.1:6379> SETRANGE str 1 xxx # SETRANGE key offset value 替换指定位置开始的字符串
(integer) 9
127.0.0.1:6379> get str
"1xxx56789"
#########
127.0.0.1:6379> SETEX str1 10 'str1' # SETEX key seconds value set with expire 设置过期时间
OK
127.0.0.1:6379> get str1
"str1"
127.0.0.1:6379> ttl str1
(integer) 0
127.0.0.1:6379> get str1
(nil)
127.0.0.1:6379> SETNX u 1 # SETNX key value set if not exist 不存在则设置，存在则失败 
(integer) 1
127.0.0.1:6379> SETNX u 1
(integer) 0
127.0.0.1:6379> get u
"1"
##########
127.0.0.1:6379> MSET k1 1 k2 2 k3 3 # MSET key value [key value ...] 设置多个值
OK
127.0.0.1:6379> MGET k1 k2 k3 # MSET key value [key value ...] 获取多个值 原子性，要么一起成功，要么一起失败
1) "1"
2) "2"
3) "3"
127.0.0.1:6379> MSETNX k4 4 k5 5 k6 6 # MSETNX key value [key value ...] 设置多个值 原子性，要么一起成功，要么一起失败
(integer) 1
127.0.0.1:6379> MSETNX k4 4 k5 5 k6 6
(integer) 0
127.0.0.1:6379> MSETNX k4 4 k7 7
(integer) 0
127.0.0.1:6379> GET k7
(nil)
### 对象
set user:1:{name:'xhl',age:10}
127.0.0.1:6379> mset user:1:name xhl user:1:age 19
OK
127.0.0.1:6379> mget user:1:name user:1:age
1) "xhl"
2) "19"
### 
127.0.0.1:6379> getset k8 10 # GETSET key value 先获取再设置，不存在返回nil，如果存在则返回，并设置新的值 
(nil)
127.0.0.1:6379> getset k8 11
"10"
```

### list

```sh
127.0.0.1:6379> LPUSH list 1 # LPUSH key value [value ...] 将一个值或者多个值插入列表头部（左）
(integer) 1
127.0.0.1:6379> LPUSH list 2
(integer) 2
127.0.0.1:6379> LRANGE list 0 -1 # LRANGE key start stop 通过区间获取
1) "2"
2) "1"
127.0.0.1:6379> RPUSH list 3 # RPUSH key value [value ...] 将一个值或者多个值插入列表尾部（右）
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "2"
2) "1"
3) "3"
127.0.0.1:6379> LPOP list # LPUSH key 从头部弹出一个值（左）
"2"
127.0.0.1:6379> RPOP list # LPUSH key 从尾部弹出一个值（左）
"3"
127.0.0.1:6379> LRANGE list 0 -1
1) "1"
127.0.0.1:6379> LINDEX list 0 # LINDEX key index 获取索引 index 的值
"1"
127.0.0.1:6379> LLEN list # LLEN key 获取 list 长度
(integer) 1
####
127.0.0.1:6379> LRANGE list 0 -1 # [1, 0, 1, 2]
1) "1"
2) "0"
3) "1"
4) "2"
127.0.0.1:6379> LREM list 2 1 # LREM key count value 删除 N 个指定的值 [0, 2]
(integer) 2
127.0.0.1:6379> LPUSH list 1 # [1, 0, 2]
(integer) 3
127.0.0.1:6379> LREM list 2 1 # [0, 2]
(integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "0"
2) "2"
####
127.0.0.1:6379> LRANGE list 0 -1
1) "-1"
2) "0"
3) "2"
4) "3"
127.0.0.1:6379> LTRIM list 1 2 # LTRIM key start stop 截取指定长度的值
OK
127.0.0.1:6379> LRANGE list 0 -1
1) "0"
2) "2"
####
127.0.0.1:6379> LRANGE list 0 -1
1) "-1"
2) "0"
3) "2"
4) "3"
127.0.0.1:6379> RPOPLPUSH list other # RPOPLPUSH source destination 移除列表尾部到另一个列表头部
"3"
127.0.0.1:6379> LRANGE list 0 -1
1) "-1"
2) "0"
3) "2"
127.0.0.1:6379> LRANGE other 0 -1
1) "3"
####
127.0.0.1:6379> EXISTS list1 # 是否存在
(integer) 0
127.0.0.1:6379> LSET list1 0 2 # LSET key index value 更新数组某个索引值 需要在数组存在，且索引存在时才能更新值
(error) ERR no such key
127.0.0.1:6379> Lpush list1 1
(integer) 1
127.0.0.1:6379> LRANGE list1 0 -1
1) "1"
127.0.0.1:6379> LSET list1 0 2
OK
127.0.0.1:6379> LRANGE list1 0 -1
1) "2"
127.0.0.1:6379> LSET list1 1 2
(error) ERR index out of range
####
127.0.0.1:6379> LRANGE list 0 -1
1) "2"
2) "0"
3) "2"
127.0.0.1:6379> LINSERT list before 0 1 # LINSERT key BEFORE|AFTER pivot value 在某个值的前/后插入值
(integer) 4
127.0.0.1:6379> LINSERT list after 0 1
(integer) 5
127.0.0.1:6379> LRANGE list 0 -1
1) "2"
2) "1"
3) "0"
4) "1"
5) "2"
```

### set

```sh
127.0.0.1:6379> SADD set 1 2 2 1 # SADD key member [member ...] 给set新增一个值
(integer) 2
127.0.0.1:6379> SMEMBERS set # SMEMBERS key 获取集合所有的值
1) "1"
2) "2"
127.0.0.1:6379> SISMEMBER set 1 # SISMEMBER key value 判断某个值在不在集合中
(integer) 1
127.0.0.1:6379> SISMEMBER set 0
(integer) 0
127.0.0.1:6379> SCARD set # SCARD key 获取集合个数
(integer) 2
127.0.0.1:6379> SREM set 1 # SREM key value 删除某个值
(integer) 1
127.0.0.1:6379> SMEMBERS set
1) "2"
####
127.0.0.1:6379> SMEMBERS set 
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> SRANDMEMBER set # SRANDMEMBER key 随机抽一个元素
"4"
127.0.0.1:6379> SRANDMEMBER set
"4"
127.0.0.1:6379> SRANDMEMBER set
"5"
127.0.0.1:6379> SRANDMEMBER set
"4"
127.0.0.1:6379> SRANDMEMBER set
"2"
127.0.0.1:6379> SRANDMEMBER set
"3"
#### 
127.0.0.1:6379> SPOP set 1 # SPOP key list 随机删除某个元素
1) "4"
127.0.0.1:6379> SPOP set 2
1) "2"
2) "5"
####
127.0.0.1:6379> SMOVE set set1 2
(integer) 0
127.0.0.1:6379> SMEMBERS set
1) "1"
2) "3"
127.0.0.1:6379> SMOVE set set1 1 # SMOVE source destination member 把元素从 source 移动到 destination 中
(integer) 1
127.0.0.1:6379> SMEMBERS set1
1) "1"
127.0.0.1:6379> SMEMBERS set
1) "3"
####
127.0.0.1:6379> SMEMBERS set
1) "1"
2) "2"
3) "3"
127.0.0.1:6379> SMEMBERS set1
1) "1"
127.0.0.1:6379> SDIFF set set1 # SDIFF key [key...] 获取 N 个集合的差集
1) "2"
2) "3"
127.0.0.1:6379> SINTER set set1 # SINTER key [key...] 获取 N 个集合的交集
1) "1"
127.0.0.1:6379> SUNION set set1 # SUNION key [key...] 获取 N 个集合的并集
1) "1"
2) "2"
3) "3"
```

## mysql

### InnoDB和MyISAM的区别

|          |          InnoDB          |   MyISAM   |
| :------: | :----------------------: | :--------: |
|   事务   |           支持           |   不支持   |
|    锁    |  支持**MVCC**行锁、表锁  |    表锁    |
|   外键   |           支持           |   不支持   |
| 存储空间 |  由于需要高速缓存，较大  |   可压缩   |
| 适用场景 | 有一定量的update和Insert | 大量的查询 |

### 什么是事务?

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

**原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；

**隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

**持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

**同时有多个事务在进行会怎么样呢?**

多事务的并发进行一般会造成以下几个问题:

- 脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- 不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- 幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".

### 事务隔离级别有哪些?MySQL的默认隔离级别是?

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：**  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

### 数据库主从复制，读写分离

#### 什么是主从复制

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；

主从复制的原理：

1. 数据库有个bin-log二进制文件，记录了所有的sql语句。
2. .只需要把主数据库的bin-log文件中的sql语句复制。
3. 让其从数据的relay-log重做日志文件中在执行一次这些sql语句即可。

主从复制的作用

1. 做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
2. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问频率，提高单机的I/O性能
3. 主从复制是读写分离的基础，使数据库能制成更大 的并发。例如子报表中，由于部署报表的sql语句十分慢，导致锁表，影响前台的服务。如果前台服务使用master，报表使用slave，那么报表sql将不会造成前台所，保证了前台的访问速度。

主从复制的几种方式：

1. 同步复制：所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。
2. 异步复制：如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。
3. 半同步复制：master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MYSQL引入的。

关于读写分离

在完成主从复制时，由于slave是需要同步master的。所以对于insert/delete/update这些更新数据库的操作，应该在master中完成。而select的查询操作，则落下到slave中。

### 数据库索引

什么是索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

索引类型

1. FULLTEXT 全文索引

   全文索引，仅MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

2. HASH 哈希索引

   HASH索引的唯一性及类似键值对的形式十分适合作为索引，HASH索引可以一次定位，不需要像树形索引那样逐层参照，因此具有极高的效率。但是这种高效是有条件的。即只在“=”和“in”条件下高效，对于范围查询，排序及组合索引仍然效率不高。

3. BTREE 树形索引

   BTREE所以是一种将索引按一定算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，一次遍历node，获取leaf。这是MySQL中默认也是最常用的索引类型。

4. RTREE

   RTREE在MySQL中很少使用，仅支持geometry数据类型，支持该存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。

索引种类

普通索引：仅加速查询

唯一索引：加速查询+列值唯一（可以有null）

主键索引：加速查询+列值唯一（不可以有null）+表中只有一个

组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

全文索引：对文本内容进行分词，进行搜索

外键索引：与主键索引形成联系，保证数据的完整性。

索引使用的注意事项

1. 符合索引遵循前缀原则
2. like查询%不能再前，否则索引失效。如有需要，使用全文索引
3. column is null可以使用索引
4. 如果MySQL估计使用索引比全表扫描慢，则放弃使用索引
5. 如果``or``前的条件中列有索引，后面的没有，索引不会生效。
6. 列类型是字符串，查询时，一定要给值加引号，否则索引失效。
7. 确定order by 和 group by 中只有一个表的列，这样才能使用索引

### 高并发的解决方案

web服务器优化 ：负载均衡 

流量优化：防盗链处理 将恶意请求屏蔽，

前端优化：减少http请求、添加异步请求、启用浏览器缓存和文件压缩、cdn加速、建立独立的图片服务器

服务端优化： 页面静态化、并发处理、队列处理、

数据库优化： 数据库缓存、分库分表、分区操作 、读写分离、负载均衡

### MVC的理解

1. Model（业务模型）：应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。　　　　　　　　　　
2. view（视图）：应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
3. controller（控制器）：应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

### 常见的设计模式

#### 策略模式
策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。

策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。
策略模式的三个角色：
1．抽象策略角色
2．具体策略角色
3．环境角色（对抽象策略角色的引用）
实现步骤：
1．定义抽象角色类（定义好各个实现的共同抽象方法）
2．定义具体策略类（具体实现父类的共同方法）
3．定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）
就在编程领域之外，有许多例子是关于策略模式的。例如：
如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。

#### 工厂模式

工厂模式是我们最常用的实例化对象模式，是用工厂方法代替``new``操作的一种模式。
使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（``new``处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 

#### 单例模式

 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。
单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。
单例模式有以下3个特点：
1．只能有一个实例。
2．必须自行创建这个实例。
3．必须给其他对象提供这一实例。
那么为什么要使用PHP单例模式？
PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的``new``操作。因为每一次``new``操作都会消耗系统和内存的资源。

#### 注册模式

注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。 

#### 适配器模式

将各种截然不同的函数接口封装成统一的API。
PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 
首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。

 

#### sql语句应该考虑哪些安全性

防止sql注入，对特殊字符进行转义，过滤或者使用预编译sql语句绑定

使用最小权限原则，特别是不要使用root账户，为不同的动作或者操作建立不同的账户

当sql出错时，不要把数据库出错的信息暴露到客户端

#### 优化mysqi数据库的方法

选取适当的字段，打字段设置为NOT NULL，在查询的时候数据库不用比较NULL；

使用链接（join）代替子查询；

使用联合（UNION）查询代替手动创建临时表；

尽量减少使用（LIKE）关键字和通配符

使用事务和外健

#### 为什么要尽量设定一个主键?

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

#### 数据库三范式是什么?

第一范式（1NF）：字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。

满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。>所以第三范式具有如下特征：>>1. 每一列只有一个值 >>2. 每一行都能区分。>>3. 每一个表都不包含其他表已经包含的非主关键字信息。

## 安全

### CSRF 攻击

CSRF(Cross-site request forgery), 中文名称：跨站请求伪造，也被称为：one click attack/session riding， 缩写为：CSRF/XSRF

CSRF 可以简单理解为：**攻击者盗用了你的身份，以你的名义发送恶意请求，**容易造成个人隐私泄露以及财产安全。

<img src="https://pic4.zhimg.com/v2-0c63c4193d48b8f42c4a4f53d82330df_r.jpg" alt="preview" style="zoom:50%;" />

如上图所示：要完成一次 CSRF 攻击，受害者必须完成：

1. 登录受信任网站，并在本地生成 cookie
2. 在不登出 A 的情况下，访问危险网站 B

**CSRF 攻击时源于 WEB 的隐式身份验证机制！WEB 的身份验证机制虽然可以保证一个请求是来自某个用户的浏览器，但无法保证该请求是经过用户批准发送的。**

CSRF 防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般 CSRF 防御液都在服务端进行的。

- 关键操作只接受 POST 请求
- 验证码：

CSRF 攻击的过程，往往是在用户不知情的情况下发生的，在用户不知情的情况下构造网络请求，所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 的攻击。

但是如果你自啊一个网站作出任何举动都要输入验证码的话会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。

- 检测 Referer：

通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。

- Token：目前主流的做法是使用 Token 防御 CSRF 攻击

CSRF 攻击要成功的条件在于攻击者能够准确地预测所有的参数从而构造出合法的请求，所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击，可以保存其原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击，所以我们在构造请求时候只需要保证：

1. Token 要足够随机，使攻击者无法准确预测
2. Token 是一次性的，即每次请求成功后要更新 Token，增加预测难度
3. Token 要主要保密性，敏感操作使用 POST，防止 Token 出现在 URL 中

**最后值得注意的是，过滤用户输入的内容不能阻挡 CSRF 攻击，我们需要做的事过滤请求的来源，因为有些请求是合法，有些是非法的，所以 CSRF 防御主要是过滤那些非法伪造的请求来源。**

### XSS 攻击

XSS 又称为 CSS，全程为 Cross-site script，跨站脚本攻击，为了和 CSS 层叠样式表区分所以取名为 XSS，是 Web 程序中常见的漏洞。

其原理是攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时候，该段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户的 Cookie，破坏页面结构，重定向到其它网站等。

#### XSS 类型

一般可以分为： 持久型 XSS 和非持久性 XSS

1. 持久型 XSS 就是对客户端攻击的脚本植入到服务器上，从而导致每个正常访问到的用户都会遭到这段 XSS 脚本的攻击。
2. 非持久型 XSS 是对一个页面的 URL 中的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数重，再将这个 URL 发布到网上，骗取用户访问，从而进行攻击

非持久性 XSS 的安全威胁比较小，因为只要服务器调整业务代码进行过滤，黑客精心构造的这段 URL 就会瞬间失效了，而相比之下，持久型 XSS 的攻击影响力很大，有时候服务端需要删好几张表，查询很多库才能将恶意代码的数据进行删除。

#### 如何防御 XSS 攻击？

理论上，网站上所有可输入的地方没有对输入内容进行处理的话，都会存在 XSS 漏洞，漏洞的危险取决于攻击代码的威力，攻击代码也不局限于 script，防御 XSS 攻击最简单直接的方法就是过滤用户的输入。

- 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML 转义

- 当用户需要输入 HTML 代码时，当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。

  更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。

## 分布式

### 分布式锁

​	分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性

1. 互斥性：在任意一个时刻，只有一个客户端持有锁。
2. 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
3. 容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁

分布式事务